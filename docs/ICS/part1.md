## session1

==区分位级运算和逻辑运算==：位级运算操作的是位，逻辑运算只看是不是0

- 移位运算
  - 右移区分逻辑右移和算术右移
    - 逻辑右移用0补齐高位（一般是无符号数）
    - 算术右移用符号位补齐高位（一般是有符号数）
- ！！！位运算要加上括号（`datalab`有很多题都是因为这个有bug）
- 基本数据类型
  - `char` 1byte
    - 对于`char s[]=“ILOVEICS”`
      - `sizeof(s)`计算的是加上`\0`的长度
      - `strlen(s)`计算的是不加`\0`的长度
  - `unsigned char` 1byte
  - `short` 2byte
  - `int` 4byte
    - TMAX=2147483647
    - -TMIN=TMIN
  - `long` 8byte
  - `float` 4byte
  - `double` 8byte
  - `ptr` 根据机器分为4byte-8byte

  ==强制浮点数转化为整数==：直接截断小数部分，保留整数部分

  ==强制无符号和有符号互转==：改变解释的方式，内容不变

- 补码的定义（最高位是负权）
  - $B2U_w$意味着把一个w位二进制的向量转化为无符号数
  - $B2T_w$意味着把一个w位二进制的向量转化为有符号数
  - $U2T_w$意味着把一个w位二进制的向量表示的无符号数转化为有符号数
    $$
    for \space \vec{x}=[x_{w-1},...,x_{0}]\\
    B2T_{w}=-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^{i}
    $$

- 数据的表示方法
  - **高位字节 (Most Significant Byte, MSB):** 代表一个数值中“最大”的部分，比如数字 `1234` 中的 `12`
  - **低位字节 (Least Significant Byte, LSB):** 代表一个数值中“最小”的部分，比如数字 `1234` 中的 `34`。
  - 大端法
    - 高位字节（MSB）存储在内存的**低地址**处，低位字节（LSB）存储在内存的**高地址**处。
  - 小端法（**x86-64常见**）
    - 低位字节（LSB）存储在内存的**低地址**处，高位字节（MSB）存储在内存的**高地址**处。
  - ！！！**主要是针对的占用多个字节的基本数据类型**，字符串没有大小端一说。
- 数字拓展
  - 无符号拓展：高位补0
  - 有符号拓展：高位补符号位
- 数字截断
  - 无符号数截断：直接截断
  - 有符号数截断：直接截断，但是截断之后的最高位被解释为符号位（可能带来错误）
- ==隐式类型转换==:**常考**

> #### 核心原则：寻找“共同的更高等级类型”
>
> 所有转换规则的最终目的，都是为了在运算时将操作数转换为一个统一的、数据表示范围更广的类型，以避免信息丢失。这个转换的优先级链条如下：
>
> **`long double` \> `double` \> `float` \> (`unsigned long long` \> `long long`) \> (`unsigned long` \> `long`) \> (`unsigned int` \> `int`)**
>
> 这个链条是理解一切算术转换的基础。
>
> ---
>
> #### 转换流程
>
> 对于任何算术运算（如 `+`, `-`, `*`, `/`, `<` 等），转换过程分为两大步：
>
> ##### **第一步：整型提升**
>
> 这是预处理步骤，发生在真正的算术转换之前。
>
> - **规则**: 任何比 `int` “小”的整型（`bool`, `char`, `signed char`, `unsigned char`, `short`, `signed short`, `unsigned short`）都会被**自动提升为 `int`**。(==注意符号拓展==)
> - **例外**: 如果 `int` 不足以表示原始类型的所有值（例如 `unsigned short` 和 `int` 位数相同），则会提升为 `unsigned int`。
> - **目的**: CPU 处理 `int` 大小的数据效率最高。此举统一了运算的基本单位，简化了计算。
>
> **示例**:
>
> ```cpp
> char c1 = 10;
> char c2 = 20;
> auto result = c1 + c2; // 在相加前，c1 和 c2 都被提升为 int，所以 result 的类型是 int
> ```
>
> ##### **第二步：常规算术转换 (Usual Arithmetic Conversions)**
>
> 在整型提升后，如果操作数的类型仍然不同，编译器会沿着前面提到的“类型等级链”进行转换。
>
> - **浮点数优先**: 如果有任何一个操作数是浮点类型，另一个就会被转换为等级最高的那个浮点类型。
>   - `int + double` -\> 两个数都变成 `double`。
>
> - **整数间的转换：关键在于“无符号传染”**
>   如果两个操作数都是整数，此时就会发生最微妙也最关键的转换：
>   1. **等级不同**: 将等级低的转换为等级高的。
>       - `int + long` -\> `int` 转换为 `long`。
>
> 1. **等级相同，但符号不同 (核心陷阱)**: 这是“**无符号具有传染性**”这条规则的体现。
>     - **规则**: 当有符号类型（如 `int`）和无符号类型（如 `unsigned int`）混合运算时，**有符号类型会被转换为无符号类型**。
>     - **背后原理**: 编译器不会改变底层的二进制位模式，而是改变对这个位模式的“解释方式”。一个负数（其补码最高位为1）在被解释为无符号数时，会成为一个非常大的正数。
>
> **经典陷阱示例**:
>
> ```cpp
> int i = -1;
> unsigned int u = 1;
>
> // i 会被转换为 unsigned int
> // -1 的二进制 (32位补码): 11111111 11111111 11111111 11111111
> // 作为 unsigned int 解释: 这是一个非常大的正数 (4294967295)
> // 因此，比较实际上是：4294967295 < 1，结果为 false
> if (i < u) {
>     // 这段代码永远不会执行！
> }
> ```
>
> **`size_t` 就是一个典型的例子**。`size_t` 本质上是无符号整型（通常是 `unsigned int` 或 `unsigned long long`），常用于表示大小和索引。在循环和比较中与 `int` 混合使用时要格外小心。
>
> ---
>
> #### 特殊规则：赋值转换
>
> 赋值操作 (`=`) 不遵循上述的算术转换规则。它的规则非常简单直接：
>
> - **规则**: 右边的值（右值）的类型**必须**被转换为左边变量（左值）的类型。
> - **风险**: 这可能导致**窄化转换 (Narrowing Conversion)**，即从一个表示范围更广的类型转换为一个范围更窄的类型，从而导致数据丢失或值被改变。
>
> **示例**:
>
> ```cpp
> int x = 3.14;       // double 3.14 被转换为 int，小数部分丢失，x 变为 3
> char c = 1000;      // 1000 超出 char 范围，发生溢出，c 的值未定义（通常是取低8位）
> ```

- 整数运算
  - 无符号加法
    - 溢出：$s=x+y=x+y-2^{w}$
    - 判断溢出的办法 $s<x$或者$s<y$（有一个满足即可）
  - 有符号数加法（补码加法）（溢出之后计算不可靠，但可以按照补码进一步计算）
    - 对满足$-2^{w-1}<=x,y<=2^{w-1}-1$的$x,y$
    - 正溢出：$s=x+y=x+y-2^w$，溢出后成了负数
    - 负溢出：$s=x+y=x+y+2^w$，溢出后成了正数
  - 乘法
    - 乘以常数：可以通过组合左移和加法来实现
    - 除法：针对除以2的幂
      - 向下舍入：$x/b=x>>k,b=2^k$（负数除符号位都代表正权重，丢了就向负无穷舍入）
      - 向上舍入：$x/b=(x+(1<<k)-1)>>k,b=2^k$（有余数的可以进位，没有余数的不受影响）
- 浮点数
  - 定点数
    - 小数点固定，左侧为非负权，右侧为负权
  - 浮点数（IEEE标准）
    - $V=(-1)^{s}\times M \times 2^E$
      - S：sign，符号位，决定浮点数的符号
      - M：frac，尾数位，是一个2进制小数，最高位为$2^{-1}$
      - E：exp，阶码位，为浮点数加权
    - 规格化的值（exp不全为0也不全为1）
      - 阶码字段被解释为以偏置形式表示的有符号整数，值为$E=e-Bias,Bias=2^{k-1}-1$，k为阶码位的长度，
        - 单精度$-126<=E<=127,k=8$
        - 双精度$-1022<=E<=1023,k=11$
          - 注意全1和全0不被考虑，所以范围-2
      - 尾数定义为$M=1+f$，即隐含的1开头
        - 任何一个非零的二进制数，都可以被规格化为 $1.xxxx...×2^{E}$ 的形式。(这一点由exp位保证)
        - 这样可以获得一位额外的精度

    - 非规格化的值（exp全为0）
      - 阶码位为$E=1-Bias$
      - 尾数为$M=f$
      - 提供了渐进下溢的手段（精度随数值变小而降低），均匀地接近0
    - 特殊值（exp全为1）
      - 若frac全为0，则表示$\infin$，区分正负
      - 若frac不为0，则表示`NaN`
    - 关于做题
      - 十进制转浮点数

> 在开始转换任何数字之前，我们先做好**准备工作**：
>
> - **确定系统参数**:
>   - 阶码位数 `k`
>   - 尾数位数 `n`
> - **计算关键指数**:
>   - 偏置值 `Bias` = $2^{(k-1)} - 1$
>   - 规格化数的最小指数 `E_min` = $1 - \text{Bias}$
>   - 规格化数的最大指数 `E_max` = $(2^k - 2) - \text{Bias}$
>
> 现在，我们开始转换一个给定的十进制数 (例如 N)。
>
> #### **第 1 步：转换为二进制科学记数法**
>
> - **处理符号**: 记下 N 的符号 (正或负)，然后对它的绝对值 `|N|` 进行操作。
> - **转为二进制**: 将 `|N|` 转换为二进制。
> - **规格化**: 将二进制数写成 `1.xxxx... * 2^exp` 的形式。这个 `exp` 就是**实际指数**。
>   - _示例_: `9.5` -> `1001.1` -> `1.0011 * 2^3`。这里 `exp = 3`。
>   - _示例_: `0.125` -> `0.001` -> `1.0 * 2^-3`。这里 `exp = -3`。
>
> #### **第 2 步：判断实际指数 `exp` 所属的区间，并进行处理**
>
> ##### **情况 A: 规格化数**
>
> - **条件**: 如果 `E_min ≤ exp ≤ E_max` (在我们的例子里是 `-2 ≤ exp ≤ 3`)。
> - **您的描述**: "正常情况下应该保留小数点前的1"。
> - **精确操作**:
>   1. **符号位 S**: 根据原始符号确定 (正为0，负为1)。
>   2. **阶码 E**: `E = exp + Bias`。将结果转为 `k` 位二进制。
>   3. **尾数 M**: 取规格化形式 `1.xxxx...` 中小数点后面的 `xxxx...` 部分，截取或补0到 `n` 位。这个操作的本质就是您说的“保留小数点前的1”（作为隐藏位）。**注意舍入规则**
>
> ##### **情况 B: 溢出为无穷大**
>
> - **条件**: 如果 `exp > E_max` (在我们的例子里是 `exp > 3`)。
> - **您的描述**: "如果太大就直接+∞"。
> - **精确操作**:
>   1. **符号位 S**: 根据原始符号确定。
>   2. **阶码 E**: 全部置为 `1` (例如 `111`)。
>   3. **尾数 M**: 全部置为 `0` (例如 `0000`)。
>
> ##### **情况 C: 下溢为非规格化数**
>
> - **条件**: 如果 `exp < E_min` (在我们的例子里是 `exp < -2`)。
> - **您的描述**: "如果太小，则固定为1-bias，然后不保留小数点前的1"。
> - **精确操作 (这一步最复杂)**:
>   1. **重新表示**: 必须将原来的 `1.xxxx * 2^exp` 形式，强制转换为 `0.yyyy * 2^E_min` 的形式。
>       - 转换方法：将小数点向左移动 `E_min - exp` 位。
>       - _示例_: 假设我们的数是 `1.1 * 2^-4`，而 `E_min = -2`。我们需要将指数变为 `-2`，指数增加了 `2`，所以小数点要向左移动 `2` 位：`1.1` -> `0.11` -> `0.011`。所以原数等价于 `0.011 * 2^-2`。
>   2. **符号位 S**: 根据原始符号确定。
>   3. **阶码 E**: 全部置为 `0` (例如 `000`)。这代表了您说的“固定为1-bias”的指数。
>   4. **尾数 M**: 取新形式 `0.yyyy` 中小数点后的 `yyyy` 部分。这完美对应了您说的“不保留小数点前的1”。
>
> #### **第 3 步: 处理特殊值 `0`**
>
> 您的流程里没有单独列出 `0`，但它是一个特殊情况。
>
> - **符号位 S**: 0 (或 1 表示 -0)
> - **阶码 E**: 全部置为 `0`
> - **尾数 M**: 全部置为 `0`

- 舍入
  - 精度看尾数,范围看指数
  - float有24位精度(1位隐藏和23位小数位)
    - int转float会舍入不会溢出
    - 不能精确表示的最小整数为$2^{24}+1$

  - double有53位精度(1位隐藏和52位小数位)
    - int转double不会舍入也不会溢出
    - 不能精确表示的最小整数为$2^{53}+1$

  - ==**整型除法向0舍入，右移向负无穷舍入**==
  - 四种舍入
    - 向0舍入
    - 向正无穷舍入
    - 向负无穷舍入
    - 向最近值舍入，平局时则向偶数舍入（Round to Nearest, Ties to Even，默认）
  - 硬件实现
    - **最低有效位（LSB）**:计算后最低精度的那一位
    - GRS比特
      - **保护位 (Guard bit, G)**：超出精度范围的第一位。
      - **舍入位 (Round bit, R)**：超出精度范围的第二位。
      - **粘滞位 (Sticky bit, S)**：之后所有位的逻辑或（OR）运算结果。如果后面还有任何非0位，S就为1，否则为0。
      - 这三个位（GRS）结合起来，可以精确地决定如何舍入。下面以**“向最近值舍入，平局时则向偶数舍入”**模式为例：
        1. **如果 G=0**：说明被舍弃部分**小于**一半。此时向**更近的值**舍入（操作上等同于**向零截断**）。
        2. **如果 G=1，且 R或S中至少有一个为1**：说明被舍弃部分**大于**一半。此时向**更近的值**舍入（操作上等同于**向远离零的方向进位**）。
        3. **如果 G=1，且 R=0, S=0**：说明被舍弃部分**恰好等于**一半（平局）。此时启用第二规则“向偶数舍入”：
           - 如果 LSB 为 0（偶数），则**向下截断**。
           - 如果 LSB 为 1（奇数），则**向上进位**。
           - 最终目的都是确保结果的 LSB 为 0。

### 浮点数运算特性

浮点数在计算机中的表示和运算遵循 IEEE 754 标准，其特性与我们日常接触的实数算术有很大不同。主要差异源于其有限的精度和特殊的数值表示。

---

#### 1. 特殊值 (Special Values)

为了处理计算中的各种异常情况，浮点数标准定义了几个特殊值：

- **有符号的零 (`+0.0` 和 `-0.0`)**
  - 在数值比较上，它们是相等的 (`+0.0 == -0.0` 结果为 `true`)。
  - 但在某些运算中表现不同，这保留了符号信息。例如：
    - $1.0 / +0.0 = +\infty$ (正无穷)
    - $1.0 / -0.0 = -\infty$ (负无穷)

- **无穷大 (`±∞`)**
  - 当计算结果超出浮点数能表示的最大范围时（上溢出, Overflow），会产生无穷大。
  - 除以零也会产生无穷大，如上例所示。

- **非数值 (`NaN` - Not a Number)**
  - 表示一个未定义或无法表示的数值结果。
  - 产生场景：
    - `$0.0 / 0.0$`
    - `$\infty - \infty$`
    - 对负数求平方根等。
  - `NaN` 有一个非常独特的性质：**它不等于任何值，包括它自己**。因此，`NaN == NaN` 的结果是 `false`。

---

#### 2. 算术定律的适用性

由于舍入误差（Rounding Error）的存在，许多在实数域成立的算术定律在浮点数运算中不再完全成立。

- **交换律 (Commutative Law) - 成立**
  - 加法和乘法交换律通常是成立的。
  - $x + y = y + x$
  - $x * y = y * x$

- **结合律 (Associative Law) - 不成立**
  - 这是浮点数运算中最著名的“陷阱”之一。
  - $(x + y) + z \neq x + (y + z)$
  - **原因**：浮点数的精度是相对的。当一个绝对值非常大的数与一个非常小的数相加时，小数的精度可能会被“吞噬”（Swallowing），导致结果不精确。
  - **示例**：假设 `x = 1.0e10`, `y = -1.0e10`, `z = 1.0`。
    - `$(x + y) + z = (1.0e10 - 1.0e10) + 1.0 = 0.0 + 1.0 = 1.0$`
    - `$x + (y + z) = 1.0e10 + (-1.0e10 + 1.0) = 1.0e10 + (-1.0e10) = 0.0$` (因为 `-1.0e10 + 1.0` 的结果由于精度限制，可能仍然被舍入为 `-1.0e10`)

- **分配律 (Distributive Law) - 不成立**
  - $x * (y + z) \neq (x * y) + (x * z)$
  - **原因**：同样是由于中间步骤的舍入误差累积所致。

- **加法逆元 (Additive Inverse)**
  - 对于绝大多数数值 `x`，存在 `-x` 使得 $x + (-x) = 0.0$。
  - 但是，**`NaN` 没有加法逆元**。任何涉及 `NaN` 的算术运算结果仍然是 `NaN`。
  - 无穷大也没有传统意义上的逆元 ($\infty - \infty = NaN$)。

---

#### 3. 单调性 (Monotonicity)

- **单调性 - 成立**
  - 在不考虑 `NaN` 和 `∞` 的情况下，浮点数加法满足单调性。
  - 如果 $a \geq b$，那么 $x + a \geq x + b$。

- **严格单调性 - 不成立**
  - 如果 $a > b$，**不保证** $x + a > x + b$。
  - **原因**：当 `x` 的值非常大，而 `a` 和 `b` 的差值相对于 `x` 非常小时，$x+a$ 和 $x+b$ 可能会被舍入为同一个可表示的浮点数值。

---

#### 4. 实践中的注意事项和策略

1. **判断与比较**
    - 在进行浮点数比较时，必须时刻考虑 `±0`, `±∞`, `NaN` 这些特殊情况。
    - 判断一个值是否为 `NaN`，不能使用 `x == NaN`，而应使用 `isNaN(x)` 这样的专用函数。

2. **类型转换 (`float` to `int`)**
    - 这是一个常见的风险点，可能同时发生两种问题：
      - **溢出 (Overflow)**：如果浮点数的值超出了整数类型（如 `int`）的表示范围，转换结果是未定义的或是一个被截断的无效值。
      - **舍入 (Rounding) / 截断 (Truncation)**：小数部分会被丢弃。例如，C++ 中 `(int)3.9` 的结果是 `3`。

3. **提升计算精度**
    - **“大数吃小数”问题**：一个非常大的数加上一个非常小的数，会导致小数的有效信息丢失。
    - **优化策略**：为了保留更多有效精度，一个常见的技巧是 **优先计算大小相近的数值**。例如，在一系列数值求和时，先将它们排序，然后从小到大依次相加，通常能得到更精确的结果。
      - 用大的负数吞掉小的正数可以得到小的结果，用大的正数吞掉小的负数会得到大的结果

- 补充
  - 对于一个位运算，可以举例分析它的意图，一般来说5组数据就够发现其规律了
    - 一个常规的正数
    - 一个2的幂
    - 一个常规的负数
    - 零
    - 边界值或全1的数

  - 函数参数
    - 在定义多维数组的函数参数时，除了第一维（最左边那一维）以外，其他所有维度的长度都必须明确指定。

    - 优先级==注意==：`[]`的优先级高于`*`

    - 二维数组
      - **数组定义**: `int matrix[10][20];`
        - **函数参数声明 (两种等价写法)**:
          1. **数组表示法 (更常见)**: `void mzyFunction(int arr[][20]);`
          2. **指针表示法 (更本质)**: `void myFunction(int (*arr)[20]);`

      - **解释**: `arr` 是一个指针，指向一个包含20个`int`元素的一维数组。`[20]` 告诉编译器，每一行的“跨度”是 `20 * sizeof(int)` 字节。
    1. 三维数组
       - **数组定义**: `int cube[10][20][30];`
         - **函数参数声明 (两种等价写法)**:
           1. **数组表示法**: `void myFunction(int arr[][20][30]);`
           2. **指针表示法**: `void myFunction(int (*arr)[20][30]);`

       - **解释**: `arr` 是一个指针，指向一个 `20x30` 的二维数组。`[20][30]` 告诉编译器，每一个“平面”（第一维的元素）的大小是 `20 * 30 * sizeof(int)` 字节。这是从一个“平面”跳到下一个“平面”所需的跨度。

    2. 四维数组 (以此类推)
       - **数组定义**: `int hypercube[10][20][30][40];`
         - **函数参数声明 (两种等价写法)**:
           1. **数组表示法**: `void myFunction(int arr[][20][30][40]);`
           2. **指针表示法**: `void myFunction(int (*arr)[20][30][40]);`

       - **解释**: `arr` 是一个指针，指向一个 `20x30x40` 的三维数组。`[20][30][40]` 告诉编译器，每一个“超立方体”（第一维的元素）的大小是 `20 * 30 * 40 * sizeof(int)` 字节。

  - 非函数参数
  - 逐步替换法
  - 核心思想：从变量名开始，由内向外，逐层剥离类型构造符（`*`, `[]`, `()`），每剥离一层，就用一个临时的类型别名（`typedef`）来代表这一层，直到整个声明被分解为一系列简单的定义。
  - **通用规则步骤：**
    1. **找到核心标识符:** 在声明中找到变量名或函数名。这是我们分析的起点。
    2. **由内向外，按优先级扩展):** 从核心标识符开始，根据 C 语言的运算符优先级规则来确定下一个解析的部分。
       - **最高优先级：** `()` 改变优先级的括号。
       - **次高优先级：** `[]` (数组) 和 `()` (函数)。
       - **较低优先级：** `*` (指针)。 当你遇到多个选择时（例如，左边一个 `*`，右边一个 `[]`），总是先处理优先级高的 `[]` 或 `()`。
    3. **逐层定义类型别名:** 每当你根据第 2 步识别出一个完整的类型组合（例如，“一个包含 N 个元素的数组”或“一个指向...的指针”），就为这个组合的**元素类型**或**指向的类型**创建一个 `typedef`。然后用这个新的类型别名来简化原始声明。重复此过程，直到原始声明变得最简化。
    4. **反向代入解读:** 从最后一个、最简单的声明开始，逐层将 `typedef` 的定义代入回去，组合成一句通顺的中文描述。

  例子:

  ```c
  int *(*p[2])[3];

  // 第 3 层：定义最基础的类型 T1
  typedef int* T1[3];
  // T2 是一个类型：它是一个包含3个元素的数组，每个元素是 int* (指向int的指针)。

  // 第 2 层：用 T2 定义 T1
  typedef T1* T2;
  // T2 是一个类型：它是一个指针，指向 T1 类型的变量。

  // 第 1 层：用 T2 定义 p
  T2 p[2];
  // p 是一个变量：它是一个包含2个元素的数组，每个元素是 T2 类型的。
  ```

  - 对于数组名使用sizeof,返回的是整个数组的大小,对于指针使用sizeof,返回的是指针的大小

## session2

**使用AT&T语法**

`mnemonic source, destination`，`助记符 源操作数 目的操作数`

源操作数在前，目的操作数在后

### 寄存器

| 64位 q | 32位 l  | 16位 w  | 8位 b   | 用途/说明    |
| ------ | ------- | ------- | ------- | ------------ |
| `%rax` | `%eax`  | `%ax`   | `%al`   | 返回值       |
| `%rbx` | `%ebx`  | `%bx`   | `%bl`   | 被调用者保存 |
| `%rcx` | `%ecx`  | `%cx`   | `%cl`   | 第4个参数    |
| `%rdx` | `%edx`  | `%dx`   | `%dl`   | 第3个参数    |
| `%rsi` | `%esi`  | `%si`   | `%sil`  | 第2个参数    |
| `%rdi` | `%edi`  | `%di`   | `%dil`  | 第1个参数    |
| `%rbp` | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存 |
| `%rsp` | `%esp`  | `%sp`   | `%spl`  | 栈指针       |
| `%r8`  | `%r8d`  | `%r8w`  | `%r8b`  | 第5个参数    |
| `%r9`  | `%r9d`  | `%r9w`  | `%r9b`  | 第6个参数    |
| `%r10` | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
| `%r11` | `%r11d` | `%r11w` | `%r11b` | 调用者保存   |
| `%r12` | `%r12d` | `%r12w` | `%r12b` | 被调用者保存 |
| `%r13` | `%r13d` | `%r13w` | `%r13b` | 被调用者保存 |
| `%r14` | `%r14d` | `%r14w` | `%r14b` | 被调用者保存 |
| `%r15` | `%r15d` | `%r15w` | `%r15b` | 被调用者保存 |

`rax-rdx,eax-edx,ax-dx,al-dl`

`rsi-rdi,esi-edi,si-di,sil-dil`

`rsp-rbp,esp-ebp,sp-bp,spl-bpl`

`r8-r15,r8d-r15d,r8w-r15w,r8b-r15b`

==被调用者保存==：`rbp,rbx,r12-r15`

==调用者保存==：`r10-r11`

==结构体==：作为参数的结构体如果比较小，则可以通过寄存器传递；若返回值为一个结构体，则应当保存在调用者的栈帧里

==参数==：如果有多余的参数，则参数7是最后压栈的

### MOV

一般数据传送指令

| 指令           | 效果    | 描述                                         |
| -------------- | ------- | -------------------------------------------- |
| `MOV S, D`     | `D ← S` | 传送                                         |
| `movb`         |         | 传送字节                                     |
| `movw`         |         | 传送字                                       |
| `movl`         |         | 传送双字                                     |
| `movq`         |         | 传送四字                                     |
| `movabsq I, R` | `R ← I` | 传送绝对的四字（**==立即数==到==寄存器==**） |

零扩展数据传送指令(以寄存器或内存地址作为源，以寄存器作为目的)

| 指令        | 效果            | 描述                         |
| ----------- | --------------- | ---------------------------- |
| `MOVZ S, R` | `R ← 零扩展(S)` | 以零扩展进行传送             |
| `movzbw`    |                 | 将做了零扩展的字节传送到字   |
| `movzbl`    |                 | 将做了零扩展的字节传送到双字 |
| `movzwl`    |                 | 将做了零扩展的字传送到双字   |
| `movzbq`    |                 | 将做了零扩展的字节传送到四字 |
| `movzwq`    |                 | 将做了零扩展的字传送到四字   |

==双字到四字==：没有直接的命令，而是`movl`以64位寄存器为目标寄存器时，自动零扩展

符号扩展数据传送指令(以寄存器或内存地址作为源，以寄存器作为目的的。`cltq`指令只作用于寄存器`%eax`和`%rax`)

| 指令        | 效果                    | 描述                           |
| ----------- | ----------------------- | ------------------------------ |
| `MOVS S, R` | `R ← 符号扩展(S)`       | 传送符号扩展的字节             |
| `movsbw`    |                         | 将做了符号扩展的字节传送到字   |
| `movsbl`    |                         | 将做了符号扩展的字节传送到双字 |
| `movswl`    |                         | 将做了符号扩展的字节传送到双字 |
| `movsbq`    |                         | 将做了符号扩展的字节传送到四字 |
| `movswq`    |                         | 将做了符号扩展的字传送到四字   |
| `movslq`    |                         | 将做了符号扩展的双字传送到四字 |
| `cltq`      | `%rax ← 符号扩展(%eax)` | 把`%eax`符号扩展到`%rax`       |

### 栈指令

==只支持8byte==

| 指令          | 效果                                                              |
| ------------- | ----------------------------------------------------------------- |
| `pushq I/R/M` | $R[\%rsp] \leftarrow R[\%rsp] - 8, M[R[\%rsp]] \leftarrow I/R/M $ |
| `popq R/M`    | $I/R/M \leftarrow M[R[\%rsp]], R[\%rsp] \leftarrow R[\%rsp] + 8$  |

==注意数据的写入方向：==**无论是全局数据，栈，堆，始终是从低地址到高地址进行**

### 加载地址指令

`leaq M,R`：$R \leftarrow I+R[r_b]+R[ri]\times s$

立即数（基址，变址，乘数）

支持地址表达式，仅在该语句中不读取内存，其余地方使用需要读取内存，**不改变条件码**

==注意==**`%rsp`不能作为变址寄存器**

**地址表达式**

- 注意省略基址寄存器的时候也要加逗号

```asm
leaq (,%rdx, 1), %rdx # 逗号不可少
# 如果没有比例，则可以省略比例的逗号，将比例默认为1
```

### 算术和逻辑操作

`mnemonic source, destination`

**这里省略了数据大小标记（b,w,l,q）**

| 指令                                | 操作数       | 说明                                         | 备注                                                                    |
| ----------------------------------- | ------------ | -------------------------------------------- | ----------------------------------------------------------------------- |
| `INC`/`DEC`/`NEG`/`NOT`             | `R/M`        | 加一、减一、取负、取补                       | `NOT`不影响标志位                                                       |
| `ADD`/`SUB`/`IMUL`/`XOR`/`OR`/`AND` | `I/R/M, R/M` | 加、减、乘、异或、或、与                     | `destination = destination OP source` 不能进行内存到内存(`M/M`)的操作。 |
| `SAL`/`SHL`/`SAR`/`SHR`             | `k, R/M`     | (算术) 左移、(逻辑) 左移、算术右移、逻辑右移 | `k` 可以是立即数或 `%cl`，忽略高位。**%cl是%rcx的最低位**               |

**A是算术，H是逻辑**

- 关于移位
  - `shl $k, %reg/mem`
  - `shl %cl, %reg/mem`
  - 移位操作会把**CF**设置为最后一个被移出的位，OF设成0
- `INC/DEC`指令不改变**CF**（可以通过这两个指令的结尾都是 C 来记忆）
- `XOR`/`OR`/`AND`会将CF和OF置0

### 特殊的算术操作

**说明:** `16` 字节数在此上下文中被称为“八字” (oct words)，通常由 `%rdx` 和 `%rax` 两个寄存器组合而成。

| 指令             | 操作数  | 操作说明                                                                                    | 类别            |
| ---------------- | ------- | ------------------------------------------------------------------------------------------- | --------------- |
| `cqto`           | (无)    | `R[%rdx]:R[%rax] ← R[%rax]`                                                                 | 符号扩展        |
| `imulq` / `mulq` | `I/R/M` | `R[%rdx]:R[%rax] ← R[%rax] × I/R/M`                                                         | 有/无符号全乘法 |
| `idivq` / `divq` | `I/R/M` | **商:** `R[%rax] ← R[%rdx]:R[%rax] ÷ I/R/M` **余数:** `R[%rdx] ← R[%rdx]:R[%rax] mod I/R/M` | 有/无符号除法   |

**`%rdx`存高位，`%rax`存低位**

**`%rdx`存余数，`%rax`存商（助记：一般用来返回结果）**

### 控制

#### 主要的条件码

每次执行完**算数指令(都会改变)**之后，会有 4 个条件码被隐式的修改：

- **ZF (Zero Flag)**：当该次运算结果为 0 时置为 1，否则置为 0
- **SF (Sign Flag)**：当运算结果的符号位（最高位）为 1 时置为 1，否则置为 0
- **CF (Carry Flag)**：当两个 unsigned 类型的数做运算因**进位/借位**而发生溢出时置为 1，否则置为 0（**进位or借位**）
- **OF (Overflow Flag)**：当两个 signed 类型的数做运算而发生符号位溢出时置为 1，否则置为 0（**符号错误**）

==进位针对无符号数（CF），溢出针对有符号数（OF）==

#### 设置条件码的指令（不保存结果）

| 指令              | 操作           | 说明                                                                            |
| :---------------- | :------------- | :------------------------------------------------------------------------------ |
| **`CMP S1, S2`**  | 计算 `S2 - S1` | 执行减法操作，仅根据 `S2 - S1` 的计算结果来设置条件码。                         |
| **`TEST S1, S2`** | 计算 `S2 & S1` | 执行按位与操作，仅根据 `S2 & S1` 的结果来设置条件码。常用于检查特定位是否为 1。 |

---

#### 使用条件码的指令

### 条件码 (cc)

| 助记符              | 描述                               | 依赖的标志位组合 | 用途分类 |
| ------------------- | ---------------------------------- | ---------------- | -------- |
| **`e`** / **`z`**   | Equal / Zero 相等 / 零             | `ZF = 1`         | 相等性   |
| **`ne`** / **`nz`** | Not Equal / Not Zero 不相等 / 非零 | `ZF = 0`         | 相等性   |
| **`s`**             | Sign 符号位为 1 (负数)             | `SF = 1`         | 符号     |
| **`ns`**            | Not Sign 符号位为 0 (非负数)       | `SF = 0`         | 符号     |
| **`o`**             | Overflow 发生溢出                  | `OF = 1`         | 溢出     |
| **`no`**            | Not Overflow 未发生溢出            | `OF = 0`         | 溢出     |
| **`p`** / **`pe`**  | Parity / Parity Even 奇偶位为偶    | `PF = 1`         | 奇偶校验 |
| **`np`** / **`po`** | Not Parity / Parity Odd 奇偶位为奇 | `PF = 0`         | 奇偶校验 |

| 助记符                         | 描述                                                             | 依赖的标志位组合              | 用途分类   |
| ------------------------------ | ---------------------------------------------------------------- | ----------------------------- | ---------- |
| **`g`** / **`nle`**            | Greater / Not Less or Equal 大于 (有符号)                        | `ZF=0 AND SF=OF`              | 有符号比较 |
| **`ge`** / **`nl`**            | Greater or Equal / Not Less 大于等于 (有符号)                    | `SF = OF`                     | 有符号比较 |
| **`l`** / **`nge`**            | Less / Not Greater or Equal 小于 (有符号)                        | `SF != OF` (即 `SF ^ OF = 1`) | 有符号比较 |
| **`le`** / **`ng`**            | Less or Equal / Not Greater 小于等于 (有符号)                    | `(SF != OF) OR (ZF = 1)`      | 有符号比较 |
| **`a`** / **`nbe`**            | Above / Not Below or Equal 高于 (无符号)                         | `CF=0 AND ZF=0`               | 无符号比较 |
| **`ae`** / **`nb`** / **`nc`** | Above or Equal / Not Below / No Carry 高于等于 (无符号) / 无进位 | `CF = 0`                      | 无符号比较 |
| **`b`** / **`nae`** / **`c`**  | Below / Not Above or Equal / Carry 低于 (无符号) / 有进位        | `CF = 1`                      | 无符号比较 |
| **`be`** / **`na`**            | Below or Equal / Not Above 低于等于 (无符号)                     | `CF=1 OR ZF=1`                | 无符号比较 |

- ==**`ab`是无符号，`gl`是有符号**==
  - `Above, Below` 无符号数
  - `Less, Greater` 有符号数

##### 3.1 条件设置指令 (`SETcc`)

`SETcc` 系列指令根据条件码的状态，将一个 8 位寄存器（或内存位置）设置为 0 或 1。这常用于将布尔运算的结果存储下来。（**间接访问条件码的值**）

- **特点**:
  - **目标操作数 `R/M` 必须是 8 位寄存器（如 `al`, `bl`）或单个字节的内存**。
  - **使用前需要手动将高位清零，以避免残留数据干扰**。

##### 3.2 条件跳转指令 (`JMP` 和 `Jcc`)

跳转指令直接修改程序计数器（PC），实现代码的非顺序执行。

| 指令      | 类型       | 详细说明                                                                     |
| :-------- | :--------- | :--------------------------------------------------------------------------- |
| **`JMP`** | 无条件跳转 | 直接跳转到目标地址。                                                         |
| **`Jcc`** | 条件跳转   | `Jcc` 是一系列指令的统称，它们会检查条件码，只有在满足特定条件时才进行跳转。 |

- 关于跳转
  - 直接跳转 `jmp label`
  - 间接跳转 `jmp *operand`
    - 跳转目标是从**寄存器**或是**内存位置**读出的
    - 内存位置的话也可以是**内存表达式**
  - 通常使用 **PC 相对编码**，即指令中存储的是目标地址与下一条指令地址之间的差值。
    - 这样做可以使代码位置无关，加载到内存任何位置都能正确执行。
    - 注意,**每一行的地址指向当前行指令的第一个字节**
  - **近跳转(8 bit offset)和远跳转(32 bit offset)的二进制编码不同**

##### 3.3 条件传送指令 (`CMOVcc`)

条件传送指令是现代处理器中用于优化性能的重要指令。

- **特点**:
  - `CMOVcc R/M, R`：如果满足 `cc` 条件，就将源 `R/M` 的值传送到目标寄存器 `R`。
  - **优点**：与 `Jcc` 不同，`CMOVcc` 不会引起分支（跳转），从而避免了现代 CPU 中因分支预测失败而导致的性能损失（流水线清空）。它将分支逻辑转化为了数据流。
  - **限制**：**不支持单字节操作**；要求计算简单、无副作用，因为无论条件是否满足，源操作数都可能被求值。
  - 条件赋值和三元运算符会被翻译成这样的语句
  - 如果存在指针解引用则不会使用条件传送(其他情况包括:大量运算,可能产生副作用)

---

#### 4. `switch` 语句的实现：跳转表

使用场景: 数据差别小,分支多(4+)

高级语言中的 `switch` 语句在编译后，通常会被优化为一种非常高效的结构——**跳转表（Jump Table）**。

1. **创建跳转表**：编译器会创建一个数组，数组的每个元素都是一个代码地址，指向 `switch` 中每个 `case` 标签对应的代码块。
2. **索引和跳转**：
    - 程序运行时，获取 `switch` 变量的值。
    - 用这个值作为索引，直接在跳转表中查找对应的代码地址。
    - 使用一个间接 `JMP` 指令，直接跳转到该地址执行。

这种方式比使用一长串的 `if-else if`（在汇编层面会变成一连串的 `CMP` 和 `Jcc`）效率高得多，因为它只需要一次数组索引和一次跳转，就可以定位到正确的代码块。

### 过程

- `x86-64` 的栈向低地址方向增长，栈指针 `%rsp` 指向栈顶元素。

- `%rip`始终保存着 **CPU 接下来要执行的下一条机器指令**在内存中的地址。

- 将控制从函数 `P` 转移到函数 `Q`：
  - `call Q`：将 紧跟在 call 指令后面的那条指令的地址)作为返回地址压入栈中，并跳转到 `Q` 的起始地址。
    - `call label`：直接调用,目标为**标签地址**
    - `call *operand`：间接调用,目标为**寄存器或内存中的地址**
    - **在执行 `call` 指令之前，栈指针 `%rsp` 必须是 16 字节对齐的**。
  - `ret`：从栈中弹出返回地址，并跳转到该地址。
- 通过寄存器最多传递六个整型参数，超出六个的部分存入 `P` 的栈帧中，其中第七个参数位于栈顶。
  - `rdi,rsi,rdx,rcx,r8,r9`

- 通过栈传递参数时，所有的数据大小都向八字节的倍数对齐。

- 栈上的局部存储：通过减小 `%rsp` (栈顶指针)提前在栈上分配空间，最后加回来释放。
  - 初始调用的一般流程 `pushq %rbp; movq %rsp %rbp;`
  - 然后使用不变的`%rbp`(栈底指针)进行索引

- **栈帧** 就是在函数调用期间，在栈上为该函数专门分配的**一整块内存区域**。
  - 栈帧布局：

  ```
                    高地址 (栈底)
                    +-----------------+
                    | P 的其他栈帧内容  |
                    +-----------------+
                    | P 调用 Q 时的    |
                    | 参数构造区 (7~n)  |
                    | (Argument Build)|
                    +-----------------+
                    | 返回地址         |  <-- 属于调用者 P 的栈帧
                    | (Return Address)|
                    +-----------------+
                    | 被保存的寄存器     |  <-- 属于Q的栈帧,rbp,rbx,r12-r15
                    |(Saved Registers)|
                    +-----------------+
                    | 局部变量区        |
                    | (Local Variables)|
                    +-----------------+
                    | 参数构造区 (7~n)  |  <-- 可能在调用下一个函数的时候使用
  %rsp / 栈指针 ->   | (Argument Build)|
                    +-----------------+
                    低地址 (栈顶)
  ```

- `leaveq` 指令(释放当前函数的整个栈帧空间，并恢复调用者函数的栈帧基址。)
  - 它等效于以下两条指令：
    - **`mov %rbp, %rsp`**:

      这条指令将基址指针（`%rbp`）的值复制到栈指针（`%rsp`）。==在函数开始时，`%rbp` 被设置为当前栈帧的底部。==执行这条指令后，`%rsp` 就直接指向了栈帧的底部。这相当于一步就释放了为局部变量等分配的所有栈空间。

    - **`pop %rbp`**:

      在执行了上面的 `mov` 指令后，`%rsp` 正好指向了当初保存旧 `%rbp` 值的位置（即调用者函数的栈帧底部）。`pop %rbp` 指令会将这个旧值从栈中弹出，并恢复到 `%rbp` 寄存器中。这样一来，`%rbp` 就恢复成了调用者函数的基址指针。

- `ret` 指令
  - **从栈顶弹出一个值，并将其作为指令地址，然后跳转到该地址执行。**

### 数据

1\. 指针运算 (Pointer Arithmetic)

| 原则                   | 解释                                                                                                                                        |
| :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ |
| **指针运算的尺度伸缩** | 当对一个指向某种数据类型 $\text{T}$ 的指针进行加 $\text{N}$ 运算时，指针的实际地址会增加 $\text{N} \times \text{sizeof}(\text{T})$ 个字节。 |

**示例：** 如果 `int *p` 指向地址 $1000$，且 `sizeof(int)` 是 4 字节。

- 执行 `p + 1`，指针的新地址是 $1000 + 1 \times 4 = 1004$。
- 这种**伸缩**机制确保了 `p + 1` 总是指向数组中的**下一个**完整元素，而不是仅仅下一个字节。

2\. 联合体 (Union)

| 原则             | 解释                                                                                                         |
| :--------------- | :----------------------------------------------------------------------------------------------------------- |
| **内存共享机制** | **联合体**是一个特殊的结构，其所有成员都**共享**同一块内存起始地址。联合体的总大小等于其**最大成员**的大小。 |

**特点：**

- 任何时候只能存储**一个**成员的值。
- 改变其中一个成员的值，会影响其他共享内存的成员。
- 它常用于节省内存或以不同数据类型查看同一块数据。
- 要求符合**结构体整体对齐规则**

3\. 内存对齐原则 (Alignment Rule)

原则一：成员数据对齐（**偏移**）

> **规则：结构体中的每个成员，其存放的起始地址相对于结构体起始地址的偏移量 (offset)，必须是该成员自身大小（或其基本类型的对齐要求）的整数倍。**

原则二：结构体整体对齐 （**大小**）

> **规则：结构体作为一个整体，其总大小必须是其所有成员中最大对齐要求 (Largest Alignment Requirement) 的整数倍。**

- 补充
  - 指针做差得到的是不是地址的差值，而是其中元素的个数（**两指针类型必然相同，不相同会报错**）
    - 指针减法的结果 `ptr2 - ptr1` 在内部的计算方式是：

      $\frac{ptr2 的内存地址−ptr1 的内存地址}{(sizeof(指针指向的数据类型))}$

### ABI

**ABI（Application Binary Interface）是一套底层的、二进制层面的“协议”或“合同”**。它精确地规定了在一个特定的硬件平台和操作系统上，编译好的程序、库文件以及操作系统之间应该如何交互。

### ABI 与 API 的关键区别

| 特性     | **API (应用程序编程接口)**                                 | **ABI (应用程序二进制接口)**                                                                                                 |
| -------- | ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **层面** | **源代码**层面                                             | **二进制/机器码**层面                                                                                                        |
| **受众** | **程序员**                                                 | **编译器和链接器**                                                                                                           |
| **作用** | 定义“做什么”：提供了函数名、参数等，让程序员可以调用功能。 | 定义“怎么做”：规定了 API 在编译后如何具体实现。                                                                              |
| **例子** | `printf("Hello");`                                         | - "Hello" 字符串的地址通过 `%rdi` 寄存器传递。 - 使用 `call` 指令跳转到 `printf` 函数。 - 函数返回值通过 `%rax` 寄存器返回。 |

简单说：**API 管代码怎么写，ABI 管编译后的代码怎么运行和链接。**

### ABI 规定了哪些内容？

ABI 的“合同”条款主要包括以下几个方面：

1. **调用约定 (Calling Convention)**：这是 ABI 最核心的部分。
   - **参数传递**：函数参数是通过寄存器还是栈来传递，以及使用哪些寄存器。
   - **返回值**：函数结果存放在哪个寄存器中。
   - **寄存器使用规则**：规定了函数可以随意使用哪些寄存器，以及在使用前必须保存和恢复哪些寄存器。
   - **栈管理**：函数调用前后，由谁（调用者或被调用者）来清理栈空间。
2. **数据类型表示**：
   - 规定了 `int`, `char`, `double` 等基本数据类型的大小、内存对齐方式。
   - 规定了结构体 (`struct`) 等复合类型的内存布局和填充规则。
3. **二进制文件格式**：
   - 定义了可执行文件、目标文件（`.o`）、动态库（`.so`, `.dll`）的结构。例如，Linux 使用 ELF 格式，Windows 使用 PE 格式。
4. **系统调用接口**：
   - 定义了应用程序如何向操作系统内核请求服务（如读写文件）的具体机制。

### 为什么 ABI 至关重要？

- **互操作性**：保证了由不同编译器（如 GCC, Clang）编译的代码、用不同语言（如 C, C++）编写的模块可以被链接在一起并正确运行。
- **兼容性**：确保了一个为特定平台（例如 “Linux on x86-64”）编译的程序，可以在任何遵循相同 ABI 的系统上运行，无需重新编译。

**一个典型的例子**：在同样的 x86-64 硬件上，Windows 和 Linux 使用不同的 ABI。这就是为什么你不能直接在 Linux 上运行 Windows 的 `.exe` 程序（反之亦然）。它们的底层指令集相同，但函数调用、系统调用等规则完全不同。

### 内存分配

- x86-64 Linux内存布局
  - stack
    - 8mb
    - 存放局部变量

    - heap
      - 动态分配大小
      - `malloc,calloc,new`

    - data
      - 静态分配的数据 例如：全局变量、静态变量、字符串常量

  - Text / Shared Libraries
    - 可执行的机器指令
      - 只读,尝试写会发生段错误

### 缓冲区溢出攻击的防御策略

缓冲区溢出是一种常见的安全漏洞，攻击者可以利用它来执行恶意代码或破坏系统。为了应对这种威胁，业界发展出了多种防御技术，主要可以分为以下几类：

1. 栈保护机制 (Stack Canaries / 金丝雀值)

这是一种防止栈溢出攻击的有效技术。

- **工作原理**:
  - 在函数开始执行时（过程序言），从一个特殊的、只读的内存段中取出一个随机生成的“金丝雀值”（Canary Value），并将其放置在栈帧中关键数据（如函数返回地址）之前。
  - 在函数即将返回时（过程尾声），程序会检查栈中的金丝雀值是否与原始值保持一致。
- **检测方式**:
  - 通常使用 `xorq` 指令将栈中的金丝雀值与原始值进行异或运算。如果两者相同，结果为零，这将设置处理器的零标志位（Zero Flag）。
  - 随后，`je`（Jump if Equal）指令会根据零标志位来判断是否跳转。如果金丝雀值未被改变，程序正常返回；如果值被修改（意味着可能发生了缓冲区溢出），程序将跳转到错误处理例程，并终止程序，从而阻止攻击。

1. 数据执行保护 (DEP / NX Bit)

这种技术从根本上限制了代码的执行区域，防止攻击者在数据段（如栈或堆）中注入并执行恶意代码。

- **工作原理**:
  - 将内存页（Memory Page）标记为“可执行”或“不可执行”。通常情况下，只有存放程序代码的内存页（如 `.text` 段）才被标记为可执行。
  - 像栈、堆等用于存放数据的内存区域则被标记为“不可执行”（Non-Executable）。
- **硬件支持**:
  - 这个检查过程由处理器的内存管理单元（MMU）在硬件层面完成，因此几乎没有性能损失。现代CPU通常支持此功能（例如，Intel的XD位或AMD的NX位）。
  - 当CPU尝试执行位于不可执行内存页中的指令时，会触发一个硬件异常，从而终止恶意程序的运行。

1. 地址空间布局随机化 (ASLR)

ASLR通过随机化内存布局，极大地增加了攻击者定位和利用漏洞的难度。

- **工作原理**:
  - 程序每次启动时，其关键内存区域（如栈、堆、共享库等）的基地址都会被随机化。
  - 这使得攻击者无法预先知道恶意代码（Shellcode）或需要利用的函数（如 `system()`）的确切内存地址。
- **挑战与权衡**:
  - **随机化范围**: 随机化的范围（熵）必须足够大，才能有效抵御暴力猜测攻击。如果范围太小，攻击者仍有可能通过猜测找到正确的地址。
  - **空间效率**: 随机化的范围又不能过大，否则会造成大量的地址空间浪费，特别是在32位系统中，地址空间本身就非常有限。因此，需要在安全性和空间效率之间做出权衡。

1. 安全编程实践

这是从源头上防止缓冲区溢出漏洞的最根本方法。

- **核心思想**:
  - 在编写代码时，始终对输入数据的大小和边界进行严格的检查。
- **具体措施**:
  - **使用安全的函数**: 避免使用不安全的函数，如 `gets()`、`strcpy()`、`sprintf()` 等，因为它们不进行边界检查。
  - **替换为安全函数**: 改用更安全的替代函数，如 `fgets()`、`strncpy()`、`snprintf()` 等。这些函数允许程序员显式指定要读取或写入的最大字节数，从而可以有效防止缓冲区溢出。
  - **示例**: 使用 `fgets(buffer, size, stdin)` 代替 `gets(buffer)`，可以确保读入的数据不会超过 `buffer` 的容量 `size`。
